Directory structure:
└── 0xedev-presale-contracts/
    ├── README.md
    ├── foundry.toml
    ├── test.md
    ├── lib/
    │   ├── forge-std/
    │   ├── openzeppelin-contracts/
    │   ├── v2-core/
    │   └── v2-periphery/
    ├── src/
    │   └── contracts/
    │       ├── LiquidityLocker.sol
    │       ├── Presale.sol
    │       ├── PresaleFactory.sol
    │       └── interfaces/
    │           └── IPresale.sol
    ├── test/
    │   ├── LiquidityLockerInteractionTest.T.sol
    │   ├── PresaleFactory.T.sol
    │   └── PresaleOptionsTest.T.sol
    └── .github/
        └── workflows/
            └── test.yml

================================================
FILE: README.md
================================================
## Foundry

**Foundry is a blazing fast, portable and modular toolkit for Ethereum application development written in Rust.**

Foundry consists of:

-   **Forge**: Ethereum testing framework (like Truffle, Hardhat and DappTools).
-   **Cast**: Swiss army knife for interacting with EVM smart contracts, sending transactions and getting chain data.
-   **Anvil**: Local Ethereum node, akin to Ganache, Hardhat Network.
-   **Chisel**: Fast, utilitarian, and verbose solidity REPL.

## Documentation

https://book.getfoundry.sh/

## Usage

### Build

```shell
$ forge build
```

### Test

```shell
$ forge test
```

### Format

```shell
$ forge fmt
```

### Gas Snapshots

```shell
$ forge snapshot
```

### Anvil

```shell
$ anvil
```

### Deploy

```shell
$ forge script script/Counter.s.sol:CounterScript --rpc-url <your_rpc_url> --private-key <your_private_key>
```

### Cast

```shell
$ cast <subcommand>
```

### Help

```shell
$ forge --help
$ anvil --help
$ cast --help
```



================================================
FILE: foundry.toml
================================================
[profile.default]
optimizer = true
optimizer_runs = 200
via_ir = true
src = "src"
out = "out"
libs = ["lib"]

remmapings = [
    "@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/",
    "v2-core/=lib/v2-core/",
    "v2-periphery/=lib/v2-periphery/",
]

# See more config options https://github.com/foundry-rs/foundry/blob/master/crates/config/README.md#all-options



================================================
FILE: test.md
================================================
## 🧪 **Test Plan for Presale Platform**

---

### 🔹 **1. PresaleFactory.sol**

#### ✅ Basic Functionality

- [ ] Deploys successfully with correct fee and token. Test successful deployment: Verify creationFee, feeToken, and liquidityLocker are set correctly.
- [ ] Can create a presale with valid parameters and emits `PresaleCreated`.
- [ ] Tracks presale addresses correctly.
- [ ] Returns correct presale count from `getPresaleCount()`.
- Test ownership: Confirm the deployer is the owner using owner()

Presale Creation
Test successful presale creation with ETH fee: Pay the creationFee in ETH, check the presale address is added to presales, and verify the PresaleCreated event.

Test successful presale creation with ERC20 fee: Pay the creationFee in a mock ERC20 token, verify the transfer and event emission.

Test insufficient ETH fee: Send less than creationFee in ETH, expect InsufficientFee revert.

Test insufficient ERC20 fee: Approve less than creationFee, expect InsufficientFee revert.

Test zero address inputs: Pass address(0) for \_token, \_weth, or \_router, expect revert (handled in Presale constructor).

Test presale count: Create multiple presales and check getPresaleCount() increments correctly.

#### 💸 Fee Handling

- [ ] Reverts if ETH fee is insufficient.
- [ ] Transfers ERC20 fee if specified.
- [ ] Owner can successfully withdraw ETH fees.
- [ ] Owner can successfully withdraw ERC20 fees.
- [ ] Reverts if `setCreationFee(0)` is called.

Fee Management
Test setCreationFee: As owner, update creationFee, verify the new value.

Test setCreationFee zero value: Attempt to set creationFee to 0, expect ZeroFee revert.

Test setCreationFee non-owner: As a non-owner, attempt to update creationFee, expect revert.

Test withdrawFees ETH: Send ETH to the contract (e.g., via presale creation), call withdrawFees, verify owner receives funds.

Test withdrawFees ERC20: Send ERC20 tokens to the contract, call withdrawFees, verify owner receives tokens.

Test withdrawFees non-owner: As a non-owner, attempt to call withdrawFees, expect revert.

#### 🔒 Access Control

- [ ] Only owner can call `setCreationFee()`.
- [ ] Only owner can call `withdrawFees()`.

#### 🛠 Optional (if implemented)

- [ ] Whitelisted addresses can create presale.
- [ ] Reverts if non-whitelisted address tries to create.
- [ ] Can update and return `feeRecipient`.

---

### 🔹 **2. Presale.sol**

#### 🔧 Deployment / Initialization

- [ ] Initializes correctly with provided parameters.
- [ ] Rejects deployment with invalid caps or dates.

Test successful deployment: Deploy with valid parameters, verify pool struct fields (e.g., token, uniswapV2Router02, options).

Test invalid initialization: Pass address(0) for \_weth, \_token, \_uniswapV2Router02, or \_liquidityLocker, expect InvalidInitialization revert.

Test pool validation: Test \_prevalidatePool with invalid options (e.g., tokenDeposit = 0, hardCap = 0, start > end, liquidityBps < 5100), expect revert.

#### 📥 Token Deposit

- [ ] Creator can deposit exact number of tokens.
- [ ] Reverts if insufficient allowance.
- [ ] Reverts if deposit is called by non-creator.
- [ ] `calculateTotalTokensNeeded()` returns correct value.

Test successful deposit: As owner, approve and call deposit(), verify tokens transfer, state changes to 2, and Deposit event is emitted.

Test deposit wrong state: Call deposit() after state changes (e.g., post-finalization), expect InvalidState revert.

Test deposit non-owner: As a non-owner, call deposit(), expect revert.

Test deposit insufficient approval: Approve less than tokenDeposit, expect ERC20 transfer revert.

#### 💰 Contributions

- [ ] Accepts ETH within time window.
- [ ] Accepts stablecoin if configured.
- [ ] Reverts if before start or after end time.
- [ ] Rejects contributions after hard cap is reached.
- [ ] Tracks user contributions and token allocation.

Test successful ETH contribution: Send ETH via contribute() or receive(), verify weiRaised, contributions, and Contribution event.

Test ETH contribution paused: Pause contract, attempt contribution, expect ContractPaused revert.

Test ETH contribution wrong currency: Set currency to an ERC20, send ETH, expect ETHNotAccepted revert.

Test ETH contribution inactive: Call before deposit() (state 1) or after finalize() (state 4), expect NotActive revert.

Test ETH contribution hard cap exceeded: Send ETH exceeding hardCap, expect HardCapExceeded revert.

Test ETH contribution below minimum: Send less than min, expect BelowMinimumContribution revert.

Test ETH contribution exceeds maximum: Send more than max for a single user, expect ExceedsMaximumContribution revert.

Test ETH contribution whitelist: Enable whitelist, attempt contribution from non-whitelisted address, expect NotWhitelisted revert.

Test ETH contribution timing: Warp time before start or after end, expect NotInPurchasePeriod revert.

Test successful stablecoin contribution: Approve and call contributeStablecoin(), verify weiRaised and token transfer.

Test stablecoin contribution wrong currency: Set currency to address(0), call contributeStablecoin(), expect StablecoinNotAccepted revert.

Test stablecoin contribution edge cases: Similar to ETH (paused, inactive, caps, whitelist, timing).

#### 🔁 Refunds (Soft Cap not met or cancelation)

- [ ] Contributors can claim refund if soft cap not met.
- [ ] Creator can cancel presale.
- [ ] Tokens refunded to creator after cancelation.
- [ ] Reverts if trying to refund twice or when not eligible.

#### ✅ Finalization (Soft Cap met)

- [ ] Creator can finalize only after end and soft cap met.
- [ ] LP tokens created and sent to LiquidityLocker.
- [ ] Funds split correctly between liquidity and owner.
- [ ] Extra unsold tokens returned to creator (if any).

Test successful finalization: Meet softCap, call finalize(), verify liquidity added, LP tokens locked, ownerBalance set, and Finalized event.

Test finalization below soft cap: Raise less than softCap, expect SoftCapNotReached revert.

Test finalization wrong state: Call in state 1 or 4, expect InvalidState revert.

Test finalization non-owner: As non-owner, expect revert.

Test finalization slippage: Mock Uniswap to return less than minimum amounts, expect revert.

Test successful cancellation: Call cancel() before finalization, verify tokens returned and Cancel event.

Test cancellation wrong state: Call after finalization, expect InvalidState revert.

Test cancellation non-owner: As non-owner, expect revert.

#### 🪙 Claiming Tokens

- [ ] Contributors can claim tokens after finalize.
- [ ] Reverts if claim is called twice.

Test successful claim: After finalization, contributor claims tokens, verify transfer and TokenClaim event.

Test claim before finalization: Call in state 2, expect InvalidState revert.

Test claim after deadline: Warp past claimDeadline, expect ClaimPeriodExpired revert.

Test claim no contribution: Non-contributor calls, expect NoTokensToClaim revert.

Test claim insufficient balance: Reduce contract token balance, expect InsufficientTokenBalance revert.

Refunding
Test successful refund: After cancellation or soft cap failure, contributor calls refund(), verify funds returned and Refund event.

Test refund no contribution: Non-contributor calls, expect NoFundsToRefund revert.

Test refund insufficient balance: Reduce contract balance, expect InsufficientContractBalance revert.

Test refund wrong state: Call during active presale, expect NotRefundable revert.

Withdrawal
Test successful withdrawal: After finalization, owner withdraws ownerBalance, verify transfer and Withdrawn event.

Test withdrawal no funds: Call with ownerBalance = 0, expect NoFundsToRefund revert.

Test withdrawal non-owner: As non-owner, expect revert.

Rescue Tokens
Test successful rescue: Owner rescues unrelated tokens, verify transfer and TokensRescued event.

Test rescue presale tokens: Attempt to rescue presale tokens before cancellation, expect CannotRescuePresaleTokens revert.

Test rescue non-owner: As non-owner, expect revert.

Whitelist
Test toggle whitelist: Enable/disable whitelist, verify WhitelistToggled event.

Test update whitelist: Add/remove addresses, verify WhitelistUpdated events and mapping.

Test whitelist non-owner: As non-owner, expect revert.

Pause/Unpause
Test pause: Owner pauses, verify Paused event and state.

Test unpause: Owner unpauses, verify Unpaused event and state.

Test pause/unpause non-owner: As non-owner, expect revert.

View Functions
Test calculateTotalTokensNeeded: Verify calculation matches presale and liquidity token amounts.

Test userTokens: Check token allocation for contributors.

Test contributor tracking: Verify getContributorCount(), getContributors(), getTotalContributed(), and getContribution().

---

### 🔹 **3. LiquidityLocker.sol**

#### 🔒 Locking

- [ ] Only owner of lock can initiate a lock.
- [ ] LP tokens are held correctly until `unlockTime`.
      Test successful deployment: Verify owner is set correctly.
      Test successful lock: Owner locks tokens, verify locks array and LiquidityLocked event.

Test lock invalid token: Pass address(0), expect InvalidTokenAddress revert.

Test lock zero amount: Pass 0, expect ZeroAmount revert.

Test lock invalid time: Pass past timestamp, expect InvalidUnlockTime revert.

Test lock non-owner: As non-owner, expect revert.

#### 🔓 Unlocking

- [ ] Reverts if unlocking before `unlockTime`.
- [ ] Allows withdrawal after unlock by the lock owner.
- [ ] Reverts if anyone else tries to withdraw.
      Test successful withdrawal: Lock tokens, warp past unlockTime, withdraw as lock owner, verify transfer and LiquidityWithdrawn event.

Test withdraw invalid ID: Pass out-of-bounds \_lockId, expect InvalidLockId revert.

Test withdraw not owner: As non-lock-owner, expect NotLockOwner revert.

Test withdraw locked: Warp before unlockTime, expect TokensStillLocked revert.

Test withdraw zero amount: After withdrawal, attempt again, expect NoTokensToWithdraw revert.
Test getLock: Verify lock details are returned correctly.

Test lockCount: Lock multiple times, verify count increments.

---

## ⚠️ Edge Case Tests

- [ ] Contribution right at hard cap (boundary case).
- [ ] Contribution just before/after `start` or `end`.
- [ ] Refund attempt before end time.
- [ ] Finalize attempt before end time.
- [ ] Reentrancy (e.g., malicious token on claim/refund).
- [ ] Multiple presales running simultaneously.

---

## 🧪 Test Environment Suggestions

- Use **Foundry** (ultra fast) or **Hardhat**.
- Use **mainnet forking** to simulate actual tokens (WETH, USDC).
- Test both ETH and ERC20 fee modes.
- Write **fixtures** for reusable setup (deploy contracts, create presale).
- Use `time.increaseTo()` to simulate future timestamps.







================================================
FILE: src/contracts/LiquidityLocker.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";

contract LiquidityLocker is Ownable {
    using SafeERC20 for IERC20;

    struct Lock {
        address token;
        uint256 amount;
        uint256 unlockTime;
        address owner;
    }

    Lock[] public locks;

    event LiquidityLocked(address indexed token, uint256 amount, uint256 unlockTime, address indexed owner);
    event LiquidityWithdrawn(address indexed token, uint256 amount, address indexed owner);

    error InvalidTokenAddress();
    error ZeroAmount();
    error InvalidUnlockTime();
    error InvalidOwnerAddress();
    error InvalidLockId();
    error NotLockOwner();
    error TokensStillLocked();
    error NoTokensToWithdraw();

    constructor() Ownable(msg.sender) {}

    function lock(address _token, uint256 _amount, uint256 _unlockTime, address _owner) external onlyOwner {
        if (_token == address(0)) revert InvalidTokenAddress();
        if (_amount == 0) revert ZeroAmount();
        if (_unlockTime <= block.timestamp) revert InvalidUnlockTime();
        if (_owner == address(0)) revert InvalidOwnerAddress();

        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);
        locks.push(Lock({token: _token, amount: _amount, unlockTime: _unlockTime, owner: _owner}));

        emit LiquidityLocked(_token, _amount, _unlockTime, _owner);
    }

    function withdraw(uint256 _lockId) external {
        if (_lockId >= locks.length) revert InvalidLockId();
        Lock storage lockData = locks[_lockId]; // Renamed from 'lock'
        if (msg.sender != lockData.owner) revert NotLockOwner();
        if (block.timestamp < lockData.unlockTime) revert TokensStillLocked();
        if (lockData.amount == 0) revert NoTokensToWithdraw();

        uint256 amount = lockData.amount;
        address token = lockData.token;
        lockData.amount = 0;
        IERC20(token).safeTransfer(msg.sender, amount);

        emit LiquidityWithdrawn(token, amount, msg.sender);
    }

    function getLock(uint256 _lockId) external view returns (address, uint256, uint256, address) {
        if (_lockId >= locks.length) revert InvalidLockId();
        Lock memory lockInfo = locks[_lockId]; // Renamed from 'lock'
        return (lockInfo.token, lockInfo.amount, lockInfo.unlockTime, lockInfo.owner);
    }

    function lockCount() external view returns (uint256) {
        return locks.length;
    }
}



================================================
FILE: src/contracts/Presale.sol
================================================
//SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import {Address} from "@openzeppelin/contracts/utils/Address.sol";
import {IUniswapV2Router02} from "lib/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol";
import {IUniswapV2Factory} from "lib/v2-core/contracts/interfaces/IUniswapV2Factory.sol";
import {IPresale} from "./interfaces/IPresale.sol";
import {ReentrancyGuard} from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import {LiquidityLocker} from "./LiquidityLocker.sol";

contract Presale is IPresale, Ownable, ReentrancyGuard {
    using SafeERC20 for IERC20;
    using SafeERC20 for ERC20; // Ensure SafeERC20 works with ERC20
    using Address for address payable;

    uint256 public constant BASIS_POINTS = 10_000;
    bool public paused;
    bool public whitelistEnabled;
    uint256 public claimDeadline;
    uint256 public ownerBalance;

    LiquidityLocker public immutable liquidityLocker;

    struct PresaleOptions {
        uint256 tokenDeposit;
        uint256 hardCap;
        uint256 softCap;
        uint256 max;
        uint256 min;
        uint256 start;
        uint256 end;
        uint256 liquidityBps;
        uint256 slippageBps;
        uint256 presaleRate;
        uint256 listingRate;
        uint256 lockupDuration;
        address currency; // ERC20 or address(0) for ETH
    }

    struct Pool {
        ERC20 token;
        IUniswapV2Router02 uniswapV2Router02;
        address factory; // Added for pair address calculation
        uint256 tokenBalance;
        uint256 tokensClaimable;
        uint256 tokensLiquidity;
        uint256 weiRaised;
        address weth;
        uint8 state;
        PresaleOptions options;
    }

    mapping(address => uint256) public contributions;
    mapping(address => bool) public whitelist;
    address[] public contributors;
    Pool public pool;

    error ContractPaused();
    error ETHNotAccepted();
    error StablecoinNotAccepted();
    error NotActive();
    error ClaimPeriodExpired();
    error NoTokensToClaim();
    error InsufficientTokenBalance();
    error NoFundsToRefund();
    error InsufficientContractBalance();
    error InvalidContributorAddress();
    error HardCapExceeded();
    error BelowMinimumContribution();
    error ExceedsMaximumContribution();
    error NotWhitelisted();
    error InvalidAddress();
    error CannotRescuePresaleTokens();
    error AlreadyPaused();
    error NotPaused();
    error ZeroTokensForContribution();
    error InvalidInitialization();

    event Paused(address indexed account);
    event Unpaused(address indexed account);
    event TokensRescued(address indexed token, address indexed to, uint256 amount);
    event Withdrawn(address indexed owner, uint256 amount);
    event WhitelistToggled(bool enabled);
    event WhitelistUpdated(address indexed contributor, bool added);
    event Contribution(address indexed contributor, uint256 amount, bool isETH);

    modifier whenNotPaused() {
        if (paused) revert ContractPaused();
        _;
    }

    modifier onlyRefundable() {
        if (!(pool.state == 3 || (block.timestamp > pool.options.end && pool.weiRaised < pool.options.softCap))) {
            revert NotRefundable();
        }
        _;
    }

    constructor(
        address _weth,
        address _token,
        address _uniswapV2Router02,
        PresaleOptions memory _options,
        address _creator,
        address _liquidityLocker
    ) Ownable(_creator) {
        if (
            _weth == address(0) || _token == address(0) || _uniswapV2Router02 == address(0)
                || _liquidityLocker == address(0)
        ) {
            revert InvalidInitialization();
        }
        _prevalidatePool(_options);

        liquidityLocker = LiquidityLocker(_liquidityLocker);
        pool = Pool({
            token: ERC20(_token),
            uniswapV2Router02: IUniswapV2Router02(_uniswapV2Router02),
            factory: IUniswapV2Router02(_uniswapV2Router02).factory(),
            tokenBalance: 0,
            tokensClaimable: 0,
            tokensLiquidity: 0,
            weiRaised: 0,
            weth: _weth,
            state: 1,
            options: _options
        });
    }

    function contribute() external payable whenNotPaused {
        if (pool.options.currency != address(0)) revert ETHNotAccepted();
        if (pool.state != 2) revert NotActive();
        uint256 tokenAmount =
            userTokens(msg.sender) + ((msg.value * pool.options.presaleRate * 10 ** pool.token.decimals()) / 10 ** 18);
        if (tokenAmount == 0) revert ZeroTokensForContribution();
        _purchase(msg.sender, msg.value);
        _trackContribution(msg.sender, msg.value, true);
    }

    receive() external payable whenNotPaused {
        if (pool.options.currency != address(0)) revert ETHNotAccepted();
        if (pool.state != 2) revert NotActive();
        uint256 tokenAmount =
            userTokens(msg.sender) + ((msg.value * pool.options.presaleRate * 10 ** pool.token.decimals()) / 10 ** 18);
        if (tokenAmount == 0) revert ZeroTokensForContribution();
        _purchase(msg.sender, msg.value);
        _trackContribution(msg.sender, msg.value, true);
    }

    // New tracking function
    function _trackContribution(address _contributor, uint256 _amount, bool _isETH) private {
        if (contributions[_contributor] == 0) {
            contributors.push(_contributor); // Add new contributor
        }
        contributions[_contributor] += _amount; // Update contribution amount
        emit Contribution(_contributor, _amount, _isETH); // Emit event
    }

    // View functions for tracking
    function getContributorCount() external view returns (uint256) {
        return contributors.length;
    }

    function getContributors() external view returns (address[] memory) {
        return contributors;
    }

    function getTotalContributed() external view returns (uint256) {
        return pool.weiRaised; // Already tracked in pool.weiRaised
    }

    function getContribution(address _contributor) external view returns (uint256) {
        return contributions[_contributor];
    }

    function contributeStablecoin(uint256 _amount) external whenNotPaused {
        if (pool.options.currency == address(0)) revert StablecoinNotAccepted();
        if (pool.state != 2) revert NotActive();
        IERC20(pool.options.currency).safeTransferFrom(msg.sender, address(this), _amount);
        _purchase(msg.sender, _amount);
    }

    function deposit() external onlyOwner whenNotPaused returns (uint256) {
        if (pool.state != 1) revert InvalidState(pool.state);
        uint256 amount = pool.options.tokenDeposit;
        pool.token.safeTransferFrom(msg.sender, address(this), amount);
        pool.state = 2;
        pool.tokenBalance = amount;
        pool.tokensClaimable = _tokensForPresale();
        pool.tokensLiquidity = _tokensForLiquidity();
        emit Deposit(msg.sender, amount, block.timestamp);
        return amount;
    }

    function finalize() external onlyOwner whenNotPaused returns (bool) {
        if (pool.state != 2) revert InvalidState(pool.state);
        if (pool.weiRaised < pool.options.softCap) revert SoftCapNotReached();

        pool.state = 4;
        uint256 liquidityAmount = _weiForLiquidity();
        _liquify(liquidityAmount, pool.tokensLiquidity);
        pool.tokenBalance -= pool.tokensLiquidity;
        ownerBalance = pool.weiRaised - liquidityAmount;
        claimDeadline = block.timestamp + 90 days;

        emit Finalized(msg.sender, pool.weiRaised, block.timestamp);
        return true;
    }

    function cancel() external nonReentrant onlyOwner whenNotPaused returns (bool) {
        if (pool.state > 2) revert InvalidState(pool.state);
        pool.state = 3;
        if (pool.tokenBalance > 0) {
            uint256 amount = pool.tokenBalance;
            pool.tokenBalance = 0;
            pool.token.safeTransfer(msg.sender, amount);
        }
        emit Cancel(msg.sender, block.timestamp);
        return true;
    }

    function claim() external nonReentrant whenNotPaused returns (uint256) {
        if (pool.state != 4) revert InvalidState(pool.state);
        if (block.timestamp > claimDeadline) revert ClaimPeriodExpired();
        uint256 amount = userTokens(msg.sender);
        if (amount == 0) revert NoTokensToClaim();
        if (pool.tokenBalance < amount) revert InsufficientTokenBalance();

        pool.tokenBalance -= amount;
        contributions[msg.sender] = 0;
        pool.token.safeTransfer(msg.sender, amount);
        emit TokenClaim(msg.sender, amount, block.timestamp);
        return amount;
    }

    function refund() external nonReentrant onlyRefundable returns (uint256) {
        uint256 amount = contributions[msg.sender];
        if (amount == 0) revert NoFundsToRefund();
        if (
            pool.options.currency == address(0)
                ? address(this).balance < amount
                : IERC20(pool.options.currency).balanceOf(address(this)) < amount
        ) {
            revert InsufficientContractBalance();
        }

        contributions[msg.sender] = 0;
        if (pool.options.currency == address(0)) {
            payable(msg.sender).sendValue(amount);
        } else {
            IERC20(pool.options.currency).safeTransfer(msg.sender, amount);
        }
        emit Refund(msg.sender, amount, block.timestamp);
        return amount;
    }

    function withdraw() external onlyOwner {
        uint256 amount = ownerBalance;
        if (amount == 0) revert NoFundsToRefund();
        ownerBalance = 0;
        if (pool.options.currency == address(0)) {
            payable(msg.sender).sendValue(amount);
        } else {
            IERC20(pool.options.currency).safeTransfer(msg.sender, amount);
        }
        emit Withdrawn(msg.sender, amount);
    }

    function rescueTokens(address _token, address _to, uint256 _amount) external onlyOwner {
        if (_to == address(0)) revert InvalidAddress();
        if (_token == address(pool.token) && pool.state < 3) revert CannotRescuePresaleTokens();
        IERC20(_token).safeTransfer(_to, _amount);
        emit TokensRescued(_token, _to, _amount);
    }

    function toggleWhitelist(bool _enabled) external onlyOwner {
        whitelistEnabled = _enabled;
        emit WhitelistToggled(_enabled);
    }

    function updateWhitelist(address[] calldata _addresses, bool _add) external onlyOwner {
        for (uint256 i = 0; i < _addresses.length; i++) {
            if (_addresses[i] == address(0)) revert InvalidAddress();
            whitelist[_addresses[i]] = _add;
            emit WhitelistUpdated(_addresses[i], _add);
        }
    }

    function pause() external onlyOwner {
        if (paused) revert AlreadyPaused();
        paused = true;
        emit Paused(msg.sender);
    }

    function unpause() external onlyOwner {
        if (!paused) revert NotPaused();
        paused = false;
        emit Unpaused(msg.sender);
    }

    function calculateTotalTokensNeeded() external view returns (uint256) {
        uint256 currencyDecimals = pool.options.currency == address(0) ? 18 : ERC20(pool.options.currency).decimals(); // Fixed to ERC20
        uint256 tokenDecimals = pool.token.decimals();
        uint256 presaleTokens =
            (pool.options.hardCap * pool.options.presaleRate * 10 ** tokenDecimals) / 10 ** currencyDecimals;
        uint256 liquidityTokens = (
            (pool.options.hardCap * pool.options.liquidityBps / BASIS_POINTS) * pool.options.listingRate
                * 10 ** tokenDecimals
        ) / 10 ** currencyDecimals;
        return presaleTokens + liquidityTokens;
    }

    function _purchase(address _beneficiary, uint256 _amount) private {
        _prevalidatePurchase(_beneficiary, _amount);
        if (whitelistEnabled && !whitelist[_beneficiary]) revert NotWhitelisted();
        pool.weiRaised += _amount;
        contributions[_beneficiary] += _amount;
        emit Purchase(_beneficiary, _amount);
    }

    function _liquify(uint256 _currencyAmount, uint256 _tokenAmount) private {
        uint256 minToken = _tokenAmount * (BASIS_POINTS - pool.options.slippageBps) / BASIS_POINTS;
        uint256 minCurrency = _currencyAmount * (BASIS_POINTS - pool.options.slippageBps) / BASIS_POINTS;

        pool.token.approve(address(pool.uniswapV2Router02), _tokenAmount); // Fixed with SafeERC20 for ERC20
        address pair = IUniswapV2Factory(pool.factory).getPair(
            address(pool.token), pool.options.currency == address(0) ? pool.weth : pool.options.currency
        );
        if (pair == address(0)) {
            pair = IUniswapV2Factory(pool.factory).createPair(
                address(pool.token), pool.options.currency == address(0) ? pool.weth : pool.options.currency
            );
        }

        if (pool.options.currency == address(0)) {
            (uint256 amountToken, uint256 amountETH, uint256 liquidity) = pool.uniswapV2Router02.addLiquidityETH{
                value: _currencyAmount
            }(address(pool.token), _tokenAmount, minToken, minCurrency, address(this), block.timestamp + 600);
        } else {
            ERC20(pool.options.currency).approve(address(pool.uniswapV2Router02), _currencyAmount); // Fixed with ERC20
            (uint256 amountA, uint256 amountB, uint256 liquidity) = pool.uniswapV2Router02.addLiquidity(
                address(pool.token),
                pool.options.currency,
                _tokenAmount,
                _currencyAmount,
                minToken,
                minCurrency,
                address(this),
                block.timestamp + 600
            );
            ERC20(pool.options.currency).approve(address(pool.uniswapV2Router02), 0); // Reset approval
        }
        pool.token.approve(address(pool.uniswapV2Router02), 0); // Reset approval

        IERC20 lpToken = IERC20(pair);
        uint256 lpAmount = lpToken.balanceOf(address(this));
        if (lpAmount == 0) revert LiquificationFailed();
        uint256 unlockTime = block.timestamp + pool.options.lockupDuration;

        lpToken.approve(address(liquidityLocker), lpAmount);
        liquidityLocker.lock(pair, lpAmount, unlockTime, owner());
    }

    function _prevalidatePurchase(address _beneficiary, uint256 _amount) private view {
        PresaleOptions memory opts = pool.options;
        if (pool.state != 2) revert InvalidState(pool.state);
        if (_beneficiary == address(0)) revert InvalidContributorAddress();
        if (block.timestamp < opts.start || block.timestamp > opts.end) revert NotInPurchasePeriod();
        if (pool.weiRaised + _amount > opts.hardCap) revert HardCapExceeded();
        if (_amount < opts.min) revert BelowMinimumContribution();
        if (contributions[_beneficiary] + _amount > opts.max) revert ExceedsMaximumContribution();
    }

    function _prevalidatePool(PresaleOptions memory _options) private view {
        if (_options.tokenDeposit == 0) revert InvalidInitialization();
        if (_options.hardCap == 0 || _options.softCap < _options.hardCap / 4) revert InvalidInitialization();
        if (_options.max == 0 || _options.min == 0 || _options.min > _options.max) revert InvalidInitialization();
        if (_options.liquidityBps < 5100 || _options.liquidityBps > BASIS_POINTS) revert InvalidInitialization();
        if (_options.slippageBps > 500) revert InvalidInitialization();
        if (_options.presaleRate == 0 || _options.listingRate == 0 || _options.listingRate >= _options.presaleRate) {
            revert InvalidInitialization();
        }
        if (_options.start < block.timestamp || _options.end <= _options.start) revert InvalidInitialization();
        if (_options.lockupDuration == 0) revert InvalidInitialization();
    }

    function userTokens(address _contributor) public view returns (uint256) {
        if (pool.weiRaised == 0) return 0;
        uint256 currencyDecimals = pool.options.currency == address(0) ? 18 : ERC20(pool.options.currency).decimals(); // Fixed to ERC20
        uint256 tokenDecimals = pool.token.decimals();
        return (contributions[_contributor] * pool.options.presaleRate * 10 ** tokenDecimals) / 10 ** currencyDecimals;
    }

    function _tokensForLiquidity() private view returns (uint256) {
        uint256 currencyDecimals = pool.options.currency == address(0) ? 18 : ERC20(pool.options.currency).decimals(); // Fixed to ERC20
        uint256 tokenDecimals = pool.token.decimals();
        return (
            (pool.options.hardCap * pool.options.liquidityBps / BASIS_POINTS) * pool.options.listingRate
                * 10 ** tokenDecimals
        ) / 10 ** currencyDecimals;
    }

    function _tokensForPresale() private view returns (uint256) {
        uint256 currencyDecimals = pool.options.currency == address(0) ? 18 : ERC20(pool.options.currency).decimals(); // Fixed to ERC20
        uint256 tokenDecimals = pool.token.decimals();
        return (pool.options.hardCap * pool.options.presaleRate * 10 ** tokenDecimals) / 10 ** currencyDecimals;
    }

    function _weiForLiquidity() private view returns (uint256) {
        return (pool.weiRaised * pool.options.liquidityBps) / BASIS_POINTS;
    }
}



================================================
FILE: src/contracts/PresaleFactory.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {Address} from "@openzeppelin/contracts/utils/Address.sol";
import {Presale} from "./Presale.sol";
import {LiquidityLocker} from "./LiquidityLocker.sol";

contract PresaleFactory is Ownable {
    LiquidityLocker public liquidityLocker;

    using SafeERC20 for IERC20;
    using Address for address payable;

    mapping(address => bool) public whitelistedCreators;
    uint256 public creationFee;
    address public feeToken;
    address[] public presales;

    // Custom errors
    error InsufficientFee();
    error ZeroFee();

    event PresaleCreated(address indexed creator, address indexed presale, address token, uint256 start, uint256 end);

    constructor(uint256 _creationFee, address _feeToken) Ownable(msg.sender) {
        creationFee = _creationFee;
        feeToken = _feeToken;
        liquidityLocker = new LiquidityLocker();
        liquidityLocker.transferOwnership(address(this));
    }

    function createPresale(Presale.PresaleOptions memory _options, address _token, address _weth, address _router)
        external
        payable
        returns (address)
    {
        if (feeToken == address(0)) {
            if (msg.value < creationFee) revert InsufficientFee();
        } else {
            IERC20(feeToken).safeTransferFrom(msg.sender, address(this), creationFee);
        }

        Presale presale = new Presale(_weth, _token, _router, _options, msg.sender, address(liquidityLocker));
        presales.push(address(presale));
        emit PresaleCreated(msg.sender, address(presale), _token, _options.start, _options.end);
        return address(presale);
    }

    function setCreationFee(uint256 _fee) external onlyOwner {
        if (_fee == 0) revert ZeroFee();
        creationFee = _fee;
    }

    function withdrawFees() external onlyOwner {
        if (feeToken == address(0)) {
            uint256 balance = address(this).balance;
            if (balance > 0) {
                payable(owner()).sendValue(balance);
            }
        } else {
            uint256 balance = IERC20(feeToken).balanceOf(address(this));
            if (balance > 0) {
                IERC20(feeToken).safeTransfer(owner(), balance);
            }
        }
    }

    function getPresaleCount() external view returns (uint256) {
        return presales.length;
    }

    function getPresales() external view returns (address[] memory) {
        return presales;
    }
}



================================================
FILE: src/contracts/interfaces/IPresale.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

/**
 * This interface outlines the functions related to managing and interacting
 * with presale contracts. It includes capabilities such as depositing funds,
 * finalizing the presale, canceling the presale, claiming tokens, and refunding
 * contributions. Implementing contracts should provide the logic for these
 * operations in the context of a presale event.
 */
interface IPresale {
    /**
     * @dev Emitted when an unauthorized address attempts an action requiring specific permissions.
     */
    error Unauthorized();

    /**
     * @dev Emitted when an action is performed in an invalid state.
     * @param currentState The current state of the contract.
     */
    error InvalidState(uint8 currentState);

    /**
     * @dev Emitted when attempting to finalize a presale that has not reached its soft cap.
     */
    error SoftCapNotReached();

    /**
     * @dev Emitted when a purchase attempt exceeds the presale's hard cap.
     */
    error HardCapExceed();

    /**
     * @dev Emitted when user with no contribution attempts to claim tokens.
     */
    error NotClaimable();

    /**
     * @dev Emitted when a purchase or refund attempt is made outside the presale period.
     */
    error NotInPurchasePeriod();

    /**
     * @dev Emitted when a purchase amount is below the minimum allowed.
     */
    error PurchaseBelowMinimum();

    /**
     * @dev Emitted when a participant's purchase would exceed the maximum allowed contribution.
     */
    error PurchaseLimitExceed();

    /**
     * @dev Emitted when a refund is requested under conditions that do not permit refunds.
     */
    error NotRefundable();

    /**
     * @dev Emitted when the process of adding liquidity to a liquidity pool fails.
     */
    error LiquificationFailed();

    /**
     * @dev Emitted when the initialization parameters provided to the contract are invalid.
     */
    error InvalidInitializationParameters();

    /**
     * @dev Emitted when the pool validation parameters provided to the contract are invalid.
     */
    error InvalidCapValue();

    /**
     * @dev Emitted when the pool validation parameters provided to the contract are invalid.
     */
    error InvalidLimitValue();

    /**
     * @dev Emitted when the pool validation parameters provided to the contract are invalid.
     */
    error InvalidLiquidityValue();

    /**
     * @dev Emitted when the pool validation parameters provided to the contract are invalid.
     */
    error InvalidTimestampValue();

    /**
     * @dev Emitted when the presale contract owner deposits tokens for sale.
     * This is usually done before the presale starts to ensure tokens are available for purchase.
     * @param sender Address of the contract owner who performs the deposit.
     * @param amount Amount of tokens deposited.
     * @param timestamp Block timestamp when the deposit occurred.
     */
    event Deposit(address indexed sender, uint256 amount, uint256 timestamp);

    /**
     * @dev Emitted for each purchase made during the presale. Tracks the buyer, the amount of ETH contributed,
     * and the amount of tokens purchased.
     * @param buyer Address of the participant who made the purchase.
     * @param amount Amount of ETH contributed by the participant.
     */
    event Purchase(address indexed buyer, uint256 amount);

    /**
     * @dev Emitted when the presale is successfully finalized. Finalization may involve distributing tokens,
     * transferring raised funds to a designated wallet, and/or enabling token claim functionality.
     * @param owner Address of the contract owner who finalized the presale.
     * @param amountRaised Total amount of ETH raised in the presale.
     * @param timestamp Block timestamp when the finalization occurred.
     */
    event Finalized(address indexed owner, uint256 amountRaised, uint256 timestamp);

    /**
     * @dev Emitted when a participant successfully claims a refund. This is typically allowed when the presale
     * is cancelled or does not meet its funding goals.
     * @param contributor Address of the participant receiving the refund.
     * @param amount Amount of wei refunded.
     * @param timestamp Block timestamp when the refund occurred.
     */
    event Refund(address indexed contributor, uint256 amount, uint256 timestamp);

    /**
     * @dev Emitted when participants claim their purchased tokens after the presale is finalized.
     * @param claimer Address of the participant claiming tokens.
     * @param amount Amount of tokens claimed.
     * @param timestamp Block timestamp when the claim occurred.
     */
    event TokenClaim(address indexed claimer, uint256 amount, uint256 timestamp);

    /**
     * @dev Emitted when the presale is cancelled by the contract owner. A cancellation may allow participants
     * to claim refunds for their contributions.
     * @param owner Address of the contract owner who cancelled the presale.
     * @param timestamp Block timestamp when the cancellation occurred.
     */
    event Cancel(address indexed owner, uint256 timestamp);

    /**
     * @dev Allows for the deposit of presale tokens by the owner.
     * This function is intended to be called by the presale contract owner to
     * deposit the tokens that are to be sold during the presale.
     *
     * @return The amount of tokens deposited for the presale.
     */
    function deposit() external returns (uint256);

    /**
     * @dev Finalizes the presale, allowing for the distribution of tokens to
     * participants and the withdrawal of funds raised to the beneficiary. This
     * function is typically called after the presale ends, assuming it meets
     * any predefined criteria such as minimum funding goals.
     *
     * @return A boolean value indicating whether the presale was successfully
     * finalized.
     */
    function finalize() external returns (bool);

    /**
     * @dev Cancels the presale and enables the refund process for participants.
     * This function can be used in scenarios where the presale does not meet
     * its goals or if the organizer decides to cancel the event for any reason.
     *
     * @return A boolean value indicating whether the presale was successfully
     * cancelled.
     */
    function cancel() external returns (bool);

    /**
     * @dev Allows participants to claim their purchased tokens after the presale
     * is finalized. Participants call this function to receive the tokens they
     * are entitled to.
     *
     * @return The amount of tokens claimed by the caller.
     */
    function claim() external returns (uint256);

    /**
     * @dev Enables participants to request a refund of their contribution if the
     * presale is cancelled or if they are otherwise eligible for a refund
     * according to the presale's terms.
     *
     * @return The amount of funds refunded to the caller.
     */
    function refund() external returns (uint256);
}



================================================
FILE: test/LiquidityLockerInteractionTest.T.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "forge-std/Test.sol";
import "../src/contracts/PresaleFactory.sol";
import "../src/contracts/Presale.sol";
import "../src/contracts/LiquidityLocker.sol";
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

// Mock Uniswap V2 contracts
contract MockUniswapV2Factory {
    address public pair;

    constructor(address _pair) {
        pair = _pair;
    }

    function getPair(address tokenA, address tokenB) external view returns (address) {
        return pair;
    }
}

contract MockUniswapV2Pair is ERC20 {
    constructor() ERC20("LP Token", "LPT") {
        _mint(msg.sender, 1000 ether); // Mint some LP tokens for testing
    }
}

contract MockUniswapV2Router {
    address public factory;

    constructor(address _factory) {
        factory = _factory;
    }

    function addLiquidityETH(
        address token,
        uint amountTokenDesired,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external payable returns (uint amountToken, uint amountETH, uint liquidity) {
        // Simulate liquidity addition
        IERC20(token).transferFrom(msg.sender, address(this), amountTokenDesired);
        return (amountTokenDesired, msg.value, 100 ether); // Return dummy values
    }
}

contract MockToken is ERC20 {
    constructor() ERC20("Presale Token", "PST") {
        _mint(msg.sender, 1000 ether);
    }
}

contract LiquidityLockerInteractionTest is Test {
    PresaleFactory factory;
    Presale presale;
    MockUniswapV2Factory uniswapFactory;
    MockUniswapV2Router uniswapRouter;
    MockUniswapV2Pair uniswapPair;
    uint256 creationFee = 0.1 ether;

    Presale.PresaleOptions options = Presale.PresaleOptions({
        tokenDeposit: 100 ether,
        hardCap: 10 ether,
        softCap: 5 ether,
        max: 1 ether,
        min: 0.1 ether,
        start: block.timestamp + 1 days,
        end: block.timestamp + 7 days,
        liquidityBps: 6000,
        slippageBps: 200,
        presaleRate: 1000,
        listingRate: 500,
        lockupDuration: 365 days,
        currency: address(0)
    });
    address weth;

    function setUp() public {
        factory = new PresaleFactory(creationFee, address(0));
        uniswapPair = new MockUniswapV2Pair();
        uniswapFactory = new MockUniswapV2Factory(address(uniswapPair));
        uniswapRouter = new MockUniswapV2Router(address(uniswapFactory));
        weth = address(0x2); // Keep as a placeholder, not strictly needed with mocks
    }

    receive() external payable {}

    function test_LiquidityLockedAfterPresaleFinalization() public {
        MockToken presaleToken = new MockToken();
        Presale.PresaleOptions memory testOptions = options;

        // Create presale with mock Uniswap contracts
        address presaleAddr = factory.createPresale{value: creationFee}(
            testOptions,
            address(presaleToken),
            weth,
            address(uniswapRouter)
        );
        presale = Presale(payable(presaleAddr));

        // Approve and deposit tokens
        presaleToken.approve(presaleAddr, testOptions.tokenDeposit);
        presale.deposit();

        // Simulate contributions to reach soft cap
        vm.warp(testOptions.start);
        vm.deal(address(this), 10 ether);
        presale.contribute{value: 1 ether}();

        address[4] memory contributors = [
            address(0x123),
            address(0x456),
            address(0x789),
            address(0xABC)
        ];
        for (uint i = 0; i < 4; i++) {
            vm.deal(contributors[i], 10 ether);
            vm.prank(contributors[i]);
            presale.contribute{value: 1 ether}();
        }

        // Finalize presale
        vm.warp(testOptions.end + 1);
        presale.finalize();

        // Verify liquidity locking
        (, , address factoryAddr, , , , , , , ) = presale.pool();
        LiquidityLocker locker = factory.liquidityLocker();
        uint256 lockId = locker.lockCount() - 1;
        (address lockedToken, uint256 lockedAmount, uint256 unlockTime, address lockOwner) = locker.getLock(lockId);

        assertEq(lockedToken, address(uniswapPair), "Incorrect token locked (should be LP token)");
        assertGt(lockedAmount, 0, "No tokens locked in LiquidityLocker");
        assertEq(unlockTime, testOptions.end + testOptions.lockupDuration, "Incorrect unlock time");
        assertEq(lockOwner, address(this), "Incorrect lock owner");
    }

    function test_LiquidityUnlockAfterDuration() public {
        MockToken presaleToken = new MockToken();
        Presale.PresaleOptions memory testOptions = options;

        // Create presale with mock Uniswap contracts
        address presaleAddr = factory.createPresale{value: creationFee}(
            testOptions,
            address(presaleToken),
            weth,
            address(uniswapRouter) // Fixed: Use uniswapRouter instead of router
        );
        presale = Presale(payable(presaleAddr));

        // Approve and deposit tokens
        presaleToken.approve(presaleAddr, testOptions.tokenDeposit);
        presale.deposit();

        // Simulate contributions to reach soft cap
        vm.warp(testOptions.start);
        vm.deal(address(this), 10 ether);
        presale.contribute{value: 1 ether}();

        address[4] memory contributors = [
            address(0x123),
            address(0x456),
            address(0x789),
            address(0xABC)
        ];
        for (uint i = 0; i < 4; i++) {
            vm.deal(contributors[i], 10 ether);
            vm.prank(contributors[i]);
            presale.contribute{value: 1 ether}();
        }

        // Finalize presale
        vm.warp(testOptions.end + 1);
        presale.finalize();

        // Access liquidity locker and withdraw
        (, , address factoryAddr, , , , , , , ) = presale.pool();
        LiquidityLocker locker = factory.liquidityLocker();
        uint256 lockId = locker.lockCount() - 1;
        (, uint256 lockedAmount, , ) = locker.getLock(lockId);

        // Warp past lockup duration and withdraw
        vm.warp(testOptions.end + testOptions.lockupDuration + 1);
        locker.withdraw(lockId);

        // Verify withdrawal
        assertEq(IERC20(uniswapPair).balanceOf(address(locker)), 0, "Tokens not unlocked from LiquidityLocker");
        assertEq(IERC20(uniswapPair).balanceOf(address(this)), lockedAmount, "LP tokens not returned to owner");
    }
}


================================================
FILE: test/PresaleFactory.T.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "forge-std/Test.sol";
import "../src/contracts/PresaleFactory.sol";
import "../src/contracts/Presale.sol";
import "../src/contracts/LiquidityLocker.sol";
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract MockERC20 is ERC20 {
    constructor() ERC20("Mock Token", "MTK") {
        _mint(msg.sender, 1000 ether);
    }
}

interface PresaleFactoryEvents {
    event PresaleCreated(address indexed creator, address indexed presale, address token, uint256 start, uint256 end);
}

contract PresaleFactoryTest is Test, PresaleFactoryEvents {
    PresaleFactory factory;
    MockERC20 feeToken;
    address owner = address(this);
    address nonOwner = address(0x123);
    uint256 creationFee = 0.1 ether;

    Presale.PresaleOptions options = Presale.PresaleOptions({
        tokenDeposit: 1e18,
        hardCap: 10 ether,
        softCap: 5 ether,
        max: 1 ether,
        min: 0.1 ether,
        start: block.timestamp + 1 days,
        end: block.timestamp + 7 days,
        liquidityBps: 6000,
        slippageBps: 200,
        presaleRate: 1000,
        listingRate: 500,
        lockupDuration: 365 days,
        currency: address(0)
    });
    address token = address(0x1);
    address weth = address(0x2);
    address router = address(0x3);

    function setUp() public {
        feeToken = new MockERC20();
        factory = new PresaleFactory(creationFee, address(0));
    }

    receive() external payable {}

    // Deployment Tests
    function test_DeploySuccessfullyWithCorrectFeeAndToken_ETH() public view {
        assertEq(factory.creationFee(), creationFee, "Creation fee mismatch");
        assertEq(factory.feeToken(), address(0), "Fee token mismatch");
        assertTrue(address(factory.liquidityLocker()) != address(0), "LiquidityLocker not set");
    }

    function test_DeploySuccessfullyWithCorrectFeeAndToken_ERC20() public {
        factory = new PresaleFactory(creationFee, address(feeToken));
        assertEq(factory.creationFee(), creationFee, "Creation fee mismatch");
        assertEq(factory.feeToken(), address(feeToken), "Fee token mismatch");
        assertTrue(address(factory.liquidityLocker()) != address(0), "LiquidityLocker not set");
    }

    function test_Ownership() public view {
        assertEq(factory.owner(), owner, "Deployer is not owner");
    }

    // Presale Creation Tests
    function test_CreatePresaleWithValidParameters_ETH() public {
        address expectedPresale = vm.computeCreateAddress(address(factory), factory.getPresaleCount() + 2);
        vm.expectEmit(true, true, false, true);
        emit PresaleCreated(owner, expectedPresale, token, options.start, options.end);

        uint256 gasStart = gasleft();
        address presale = factory.createPresale{value: creationFee}(options, token, weth, router);
        uint256 gasUsed = gasStart - gasleft();

        assertEq(presale, expectedPresale, "Returned presale address mismatch");
        address[] memory presales = factory.getPresales();
        assertEq(presales.length, 1, "Presale not added to array");
        assertEq(presales[0], presale, "Presale address mismatch in array");
        assertTrue(address(presale).code.length > 0, "Presale address is not a contract");
        assertLt(gasUsed, 5_000_000, "Gas usage for createPresale exceeds reasonable limit");
    }

    function test_CreatePresaleWithValidParameters_ERC20() public {
        factory = new PresaleFactory(creationFee, address(feeToken));
        feeToken.approve(address(factory), creationFee);

        address expectedPresale = vm.computeCreateAddress(address(factory), factory.getPresaleCount() + 2);
        vm.expectEmit(true, true, false, true);
        emit PresaleCreated(owner, expectedPresale, token, options.start, options.end);

        address presale = factory.createPresale(options, token, weth, router);
        assertEq(presale, expectedPresale, "Returned presale address mismatch");
        assertEq(feeToken.balanceOf(address(factory)), creationFee, "ERC20 fee not transferred");
        assertEq(factory.getPresaleCount(), 1, "Presale count not incremented");
        assertTrue(address(presale).code.length > 0, "Presale address is not a contract");
    }

    function test_TracksPresaleAddressesCorrectly() public {
        address presale1 = factory.createPresale{value: creationFee}(options, token, weth, router);
        address presale2 = factory.createPresale{value: creationFee}(options, token, weth, router);
        address[] memory presales = factory.getPresales();
        assertEq(presales[0], presale1, "First presale address mismatch");
        assertEq(presales[1], presale2, "Second presale address mismatch");
    }

    function test_ReturnsCorrectPresaleCount() public {
        factory.createPresale{value: creationFee}(options, token, weth, router);
        factory.createPresale{value: creationFee}(options, token, weth, router);
        assertEq(factory.getPresaleCount(), 2, "Presale count incorrect");
    }

    function test_InsufficientETHFee() public {
        vm.expectRevert(PresaleFactory.InsufficientFee.selector);
        factory.createPresale{value: creationFee - 1}(options, token, weth, router);
    }

    function test_InsufficientERC20Fee() public {
        factory = new PresaleFactory(creationFee, address(feeToken));
        feeToken.approve(address(factory), creationFee - 1);
        vm.expectRevert(
            abi.encodeWithSelector(
                IERC20Errors.ERC20InsufficientAllowance.selector, address(factory), creationFee - 1, creationFee
            )
        );
        factory.createPresale(options, token, weth, router);
    }

    function test_ZeroAddressInputs() public {
        vm.expectRevert();
        factory.createPresale{value: creationFee}(options, address(0), weth, router);
        vm.expectRevert();
        factory.createPresale{value: creationFee}(options, token, address(0), router);
        vm.expectRevert();
        factory.createPresale{value: creationFee}(options, token, weth, address(0));
    }

    // Fee Handling Tests
    function test_OwnerCanWithdrawETHFees() public {
        factory.createPresale{value: creationFee}(options, token, weth, router);
        uint256 initialBalance = owner.balance;
        factory.withdrawFees();
        assertEq(owner.balance, initialBalance + creationFee, "ETH fees not withdrawn");
        assertEq(address(factory).balance, 0, "Factory balance not zero");
    }

    function test_OwnerCanWithdrawERC20Fees() public {
        factory = new PresaleFactory(creationFee, address(feeToken));
        feeToken.approve(address(factory), creationFee);
        factory.createPresale(options, token, weth, router);
        uint256 initialBalance = feeToken.balanceOf(owner);
        factory.withdrawFees();
        assertEq(feeToken.balanceOf(owner), initialBalance + creationFee, "ERC20 fees not withdrawn");
        assertEq(feeToken.balanceOf(address(factory)), 0, "Factory balance not zero");
    }

    function test_RevertsIfSetCreationFeeZero() public {
        vm.expectRevert(PresaleFactory.ZeroFee.selector);
        factory.setCreationFee(0);
    }

    function test_SetCreationFee() public {
        uint256 newFee = 0.2 ether;
        factory.setCreationFee(newFee);
        assertEq(factory.creationFee(), newFee, "Creation fee not updated");
    }

    function test_SetCreationFeeNonOwner() public {
        vm.prank(nonOwner);
        vm.expectRevert(abi.encodeWithSelector(Ownable.OwnableUnauthorizedAccount.selector, nonOwner));
        factory.setCreationFee(0.2 ether);
    }

    function test_WithdrawFeesNonOwner() public {
        vm.prank(nonOwner);
        vm.expectRevert(abi.encodeWithSelector(Ownable.OwnableUnauthorizedAccount.selector, nonOwner));
        factory.withdrawFees();
    }

    // Edge Case Tests
    function test_CreatePresaleWithMaxHardCap() public {
        Presale.PresaleOptions memory maxOptions = options;
        maxOptions.hardCap = type(uint256).max;
        maxOptions.softCap = type(uint256).max / 4;
        factory.createPresale{value: creationFee}(maxOptions, token, weth, router);
    }

    function test_CreatePresaleWithFeeTokenAsWeth() public {
        MockERC20 wethToken = new MockERC20();
        factory = new PresaleFactory(creationFee, address(wethToken));
        wethToken.approve(address(factory), creationFee);

        address presale = factory.createPresale(options, token, address(wethToken), router);
        assertEq(wethToken.balanceOf(address(factory)), creationFee, "WETH fee not transferred");
        assertEq(factory.getPresaleCount(), 1, "Presale count not incremented");
    }

    // Factory State Tests
    function test_FactoryETHBalanceAfterPresaleCreation() public {
        uint256 initialFactoryBalance = address(factory).balance;
        factory.createPresale{value: creationFee}(options, token, weth, router);
        assertEq(
            address(factory).balance,
            initialFactoryBalance + creationFee,
            "Factory ETH balance not increased by creation fee"
        );
    }

    function test_FactoryERC20BalanceAfterPresaleCreation() public {
        factory = new PresaleFactory(creationFee, address(feeToken));
        feeToken.approve(address(factory), creationFee);
        uint256 initialFactoryBalance = feeToken.balanceOf(address(factory));
        factory.createPresale(options, token, weth, router);
        assertEq(
            feeToken.balanceOf(address(factory)),
            initialFactoryBalance + creationFee,
            "Factory ERC20 balance not increased by creation fee"
        );
    }
}



================================================
FILE: test/PresaleOptionsTest.T.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "forge-std/Test.sol";
import "../src/contracts/PresaleFactory.sol";
import "../src/contracts/Presale.sol";

contract PresaleOptionsTest is Test {
    PresaleFactory factory;
    uint256 creationFee = 0.1 ether;

    Presale.PresaleOptions options = Presale.PresaleOptions({
        tokenDeposit: 1e18,
        hardCap: 10 ether,
        softCap: 5 ether,
        max: 1 ether,
        min: 0.1 ether,
        start: block.timestamp + 1 days,
        end: block.timestamp + 7 days,
        liquidityBps: 6000,
        slippageBps: 200,
        presaleRate: 1000,
        listingRate: 500,
        lockupDuration: 365 days,
        currency: address(0)
    });
    address token = address(0x1);
    address weth = address(0x2);
    address router = address(0x3);

    function setUp() public {
        factory = new PresaleFactory(creationFee, address(0));
    }

    receive() external payable {}

    function test_RevertIfStartAfterEnd() public {
        Presale.PresaleOptions memory invalidOptions = options;
        invalidOptions.start = block.timestamp + 7 days;
        invalidOptions.end = block.timestamp + 1 days;
        vm.expectRevert(Presale.InvalidInitialization.selector);
        factory.createPresale{value: creationFee}(invalidOptions, token, weth, router);
    }

    function test_RevertIfStartInPast() public {
        Presale.PresaleOptions memory invalidOptions = options;
        invalidOptions.start = block.timestamp - 1 days;
        invalidOptions.end = block.timestamp - 1 hours; // Ensure end > start
        vm.expectRevert(Presale.InvalidInitialization.selector);
        factory.createPresale{value: creationFee}(invalidOptions, token, weth, router);
    }

    function test_RevertIfSoftCapBelowHardCapQuarter() public {
        Presale.PresaleOptions memory invalidOptions = options;
        invalidOptions.hardCap = 10 ether;
        invalidOptions.softCap = 1 ether; // < hardCap / 4 = 2.5 ether
        vm.expectRevert(Presale.InvalidInitialization.selector);
        factory.createPresale{value: creationFee}(invalidOptions, token, weth, router);
    }

    function test_RevertIfMinExceedsMax() public {
        Presale.PresaleOptions memory invalidOptions = options;
        invalidOptions.min = 2 ether;
        invalidOptions.max = 1 ether;
        vm.expectRevert(Presale.InvalidInitialization.selector);
        factory.createPresale{value: creationFee}(invalidOptions, token, weth, router);
    }

    function test_RevertIfZeroCaps() public {
        Presale.PresaleOptions memory invalidOptions = options;
        invalidOptions.hardCap = 0;
        vm.expectRevert(Presale.InvalidInitialization.selector);
        factory.createPresale{value: creationFee}(invalidOptions, token, weth, router);
    }

    function test_RevertIfPresaleRateZero() public {
        Presale.PresaleOptions memory invalidOptions = options;
        invalidOptions.presaleRate = 0;
        vm.expectRevert(Presale.InvalidInitialization.selector);
        factory.createPresale{value: creationFee}(invalidOptions, token, weth, router);
    }

    function test_RevertIfListingRateZero() public {
        Presale.PresaleOptions memory invalidOptions = options;
        invalidOptions.listingRate = 0;
        vm.expectRevert(Presale.InvalidInitialization.selector);
        factory.createPresale{value: creationFee}(invalidOptions, token, weth, router);
    }

    function test_RevertIfLiquidityBpsExceeds10000() public {
        Presale.PresaleOptions memory invalidOptions = options;
        invalidOptions.liquidityBps = 10001;
        vm.expectRevert(Presale.InvalidInitialization.selector);
        factory.createPresale{value: creationFee}(invalidOptions, token, weth, router);
    }

    function test_RevertIfSlippageBpsExceeds500() public {
        Presale.PresaleOptions memory invalidOptions = options;
        invalidOptions.slippageBps = 501;
        vm.expectRevert(Presale.InvalidInitialization.selector);
        factory.createPresale{value: creationFee}(invalidOptions, token, weth, router);
    }

    function test_LiquidityBpsBoundaryValues() public {
        Presale.PresaleOptions memory boundaryOptions = options;
        boundaryOptions.liquidityBps = 5100; // Minimum allowed
        address presale1 = factory.createPresale{value: creationFee}(boundaryOptions, token, weth, router);
        assertTrue(presale1 != address(0), "Presale creation failed with 5100 liquidityBps");

        boundaryOptions.liquidityBps = 10000; // Maximum allowed
        address presale2 = factory.createPresale{value: creationFee}(boundaryOptions, token, weth, router);
        assertTrue(presale2 != address(0), "Presale creation failed with 10000 liquidityBps");
    }
}



================================================
FILE: .github/workflows/test.yml
================================================
name: CI

on:
  push:
  pull_request:
  workflow_dispatch:

env:
  FOUNDRY_PROFILE: ci

jobs:
  check:
    strategy:
      fail-fast: true

    name: Foundry project
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Install Foundry
        uses: foundry-rs/foundry-toolchain@v1

      - name: Show Forge version
        run: |
          forge --version

      - name: Run Forge fmt
        run: |
          forge fmt --check
        id: fmt

      - name: Run Forge build
        run: |
          forge build --sizes
        id: build

      - name: Run Forge tests
        run: |
          forge test -vvv
        id: test


